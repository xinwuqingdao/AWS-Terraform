import { Injectable } from '@angular/core';
import * as i0 from "@angular/core";
import * as i1 from "../storage/storage-persistence.service";
import * as i2 from "@angular/router";
const STORAGE_KEY = 'redirect';
class AutoLoginService {
    constructor(storageService, router) {
        this.storageService = storageService;
        this.router = router;
    }
    checkSavedRedirectRouteAndNavigate(config) {
        const savedRouteForRedirect = this.getStoredRedirectRoute(config);
        if (savedRouteForRedirect != null) {
            this.deleteStoredRedirectRoute(config);
            this.router.navigateByUrl(savedRouteForRedirect);
        }
    }
    /**
     * Saves the redirect URL to storage.
     *
     * @param config The OpenId configuration.
     * @param url The redirect URL to save.
     */
    saveRedirectRoute(config, url) {
        this.storageService.write(STORAGE_KEY, url, config);
    }
    /**
     * Gets the stored redirect URL from storage.
     */
    getStoredRedirectRoute(config) {
        return this.storageService.read(STORAGE_KEY, config);
    }
    /**
     * Removes the redirect URL from storage.
     */
    deleteStoredRedirectRoute(config) {
        this.storageService.remove(STORAGE_KEY, config);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.2", ngImport: i0, type: AutoLoginService, deps: [{ token: i1.StoragePersistenceService }, { token: i2.Router }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.0.2", ngImport: i0, type: AutoLoginService, providedIn: 'root' }); }
}
export { AutoLoginService };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.2", ngImport: i0, type: AutoLoginService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i1.StoragePersistenceService }, { type: i2.Router }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0by1sb2dpbi5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYW5ndWxhci1hdXRoLW9pZGMtY2xpZW50L3NyYy9saWIvYXV0by1sb2dpbi9hdXRvLWxvZ2luLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQzs7OztBQUszQyxNQUFNLFdBQVcsR0FBRyxVQUFVLENBQUM7QUFFL0IsTUFDYSxnQkFBZ0I7SUFDM0IsWUFDbUIsY0FBeUMsRUFDekMsTUFBYztRQURkLG1CQUFjLEdBQWQsY0FBYyxDQUEyQjtRQUN6QyxXQUFNLEdBQU4sTUFBTSxDQUFRO0lBQzlCLENBQUM7SUFFSixrQ0FBa0MsQ0FBQyxNQUEyQjtRQUM1RCxNQUFNLHFCQUFxQixHQUFHLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUVsRSxJQUFJLHFCQUFxQixJQUFJLElBQUksRUFBRTtZQUNqQyxJQUFJLENBQUMseUJBQXlCLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDdkMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMscUJBQXFCLENBQUMsQ0FBQztTQUNsRDtJQUNILENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILGlCQUFpQixDQUFDLE1BQTJCLEVBQUUsR0FBVztRQUN4RCxJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUUsR0FBRyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ3RELENBQUM7SUFFRDs7T0FFRztJQUNLLHNCQUFzQixDQUFDLE1BQTJCO1FBQ3hELE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ3ZELENBQUM7SUFFRDs7T0FFRztJQUNLLHlCQUF5QixDQUFDLE1BQTJCO1FBQzNELElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLFdBQVcsRUFBRSxNQUFNLENBQUMsQ0FBQztJQUNsRCxDQUFDOzhHQXJDVSxnQkFBZ0I7a0hBQWhCLGdCQUFnQixjQURILE1BQU07O1NBQ25CLGdCQUFnQjsyRkFBaEIsZ0JBQWdCO2tCQUQ1QixVQUFVO21CQUFDLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFJvdXRlciB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQgeyBPcGVuSWRDb25maWd1cmF0aW9uIH0gZnJvbSAnLi4vY29uZmlnL29wZW5pZC1jb25maWd1cmF0aW9uJztcbmltcG9ydCB7IFN0b3JhZ2VQZXJzaXN0ZW5jZVNlcnZpY2UgfSBmcm9tICcuLi9zdG9yYWdlL3N0b3JhZ2UtcGVyc2lzdGVuY2Uuc2VydmljZSc7XG5cbmNvbnN0IFNUT1JBR0VfS0VZID0gJ3JlZGlyZWN0JztcblxuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBBdXRvTG9naW5TZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBzdG9yYWdlU2VydmljZTogU3RvcmFnZVBlcnNpc3RlbmNlU2VydmljZSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHJvdXRlcjogUm91dGVyXG4gICkge31cblxuICBjaGVja1NhdmVkUmVkaXJlY3RSb3V0ZUFuZE5hdmlnYXRlKGNvbmZpZzogT3BlbklkQ29uZmlndXJhdGlvbik6IHZvaWQge1xuICAgIGNvbnN0IHNhdmVkUm91dGVGb3JSZWRpcmVjdCA9IHRoaXMuZ2V0U3RvcmVkUmVkaXJlY3RSb3V0ZShjb25maWcpO1xuXG4gICAgaWYgKHNhdmVkUm91dGVGb3JSZWRpcmVjdCAhPSBudWxsKSB7XG4gICAgICB0aGlzLmRlbGV0ZVN0b3JlZFJlZGlyZWN0Um91dGUoY29uZmlnKTtcbiAgICAgIHRoaXMucm91dGVyLm5hdmlnYXRlQnlVcmwoc2F2ZWRSb3V0ZUZvclJlZGlyZWN0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2F2ZXMgdGhlIHJlZGlyZWN0IFVSTCB0byBzdG9yYWdlLlxuICAgKlxuICAgKiBAcGFyYW0gY29uZmlnIFRoZSBPcGVuSWQgY29uZmlndXJhdGlvbi5cbiAgICogQHBhcmFtIHVybCBUaGUgcmVkaXJlY3QgVVJMIHRvIHNhdmUuXG4gICAqL1xuICBzYXZlUmVkaXJlY3RSb3V0ZShjb25maWc6IE9wZW5JZENvbmZpZ3VyYXRpb24sIHVybDogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5zdG9yYWdlU2VydmljZS53cml0ZShTVE9SQUdFX0tFWSwgdXJsLCBjb25maWcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHN0b3JlZCByZWRpcmVjdCBVUkwgZnJvbSBzdG9yYWdlLlxuICAgKi9cbiAgcHJpdmF0ZSBnZXRTdG9yZWRSZWRpcmVjdFJvdXRlKGNvbmZpZzogT3BlbklkQ29uZmlndXJhdGlvbik6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZVNlcnZpY2UucmVhZChTVE9SQUdFX0tFWSwgY29uZmlnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSByZWRpcmVjdCBVUkwgZnJvbSBzdG9yYWdlLlxuICAgKi9cbiAgcHJpdmF0ZSBkZWxldGVTdG9yZWRSZWRpcmVjdFJvdXRlKGNvbmZpZzogT3BlbklkQ29uZmlndXJhdGlvbik6IHZvaWQge1xuICAgIHRoaXMuc3RvcmFnZVNlcnZpY2UucmVtb3ZlKFNUT1JBR0VfS0VZLCBjb25maWcpO1xuICB9XG59XG4iXX0=