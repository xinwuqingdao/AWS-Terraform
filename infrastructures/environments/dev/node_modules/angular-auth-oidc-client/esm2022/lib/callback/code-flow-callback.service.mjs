import { Injectable } from '@angular/core';
import { throwError } from 'rxjs';
import { catchError, tap } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "../flows/flows.service";
import * as i2 from "../flows/flows-data.service";
import * as i3 from "./interval.service";
import * as i4 from "@angular/router";
class CodeFlowCallbackService {
    constructor(flowsService, flowsDataService, intervalService, router) {
        this.flowsService = flowsService;
        this.flowsDataService = flowsDataService;
        this.intervalService = intervalService;
        this.router = router;
    }
    authenticatedCallbackWithCode(urlToCheck, config, allConfigs) {
        const isRenewProcess = this.flowsDataService.isSilentRenewRunning(config);
        const { triggerAuthorizationResultEvent, postLoginRoute, unauthorizedRoute, } = config;
        return this.flowsService
            .processCodeFlowCallback(urlToCheck, config, allConfigs)
            .pipe(tap((callbackContext) => {
            this.flowsDataService.resetCodeFlowInProgress(config);
            if (!triggerAuthorizationResultEvent &&
                !callbackContext.isRenewProcess) {
                this.router.navigateByUrl(postLoginRoute);
            }
        }), catchError((error) => {
            this.flowsDataService.resetSilentRenewRunning(config);
            this.flowsDataService.resetCodeFlowInProgress(config);
            this.intervalService.stopPeriodicTokenCheck();
            if (!triggerAuthorizationResultEvent && !isRenewProcess) {
                this.router.navigateByUrl(unauthorizedRoute);
            }
            return throwError(() => new Error(error));
        }));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.2", ngImport: i0, type: CodeFlowCallbackService, deps: [{ token: i1.FlowsService }, { token: i2.FlowsDataService }, { token: i3.IntervalService }, { token: i4.Router }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.0.2", ngImport: i0, type: CodeFlowCallbackService, providedIn: 'root' }); }
}
export { CodeFlowCallbackService };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.2", ngImport: i0, type: CodeFlowCallbackService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i1.FlowsService }, { type: i2.FlowsDataService }, { type: i3.IntervalService }, { type: i4.Router }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29kZS1mbG93LWNhbGxiYWNrLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9hbmd1bGFyLWF1dGgtb2lkYy1jbGllbnQvc3JjL2xpYi9jYWxsYmFjay9jb2RlLWZsb3ctY2FsbGJhY2suc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRTNDLE9BQU8sRUFBYyxVQUFVLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDOUMsT0FBTyxFQUFFLFVBQVUsRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7Ozs7O0FBT2pELE1BQ2EsdUJBQXVCO0lBQ2xDLFlBQ21CLFlBQTBCLEVBQzFCLGdCQUFrQyxFQUNsQyxlQUFnQyxFQUNoQyxNQUFjO1FBSGQsaUJBQVksR0FBWixZQUFZLENBQWM7UUFDMUIscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFrQjtRQUNsQyxvQkFBZSxHQUFmLGVBQWUsQ0FBaUI7UUFDaEMsV0FBTSxHQUFOLE1BQU0sQ0FBUTtJQUM5QixDQUFDO0lBRUosNkJBQTZCLENBQzNCLFVBQWtCLEVBQ2xCLE1BQTJCLEVBQzNCLFVBQWlDO1FBRWpDLE1BQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxvQkFBb0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUMxRSxNQUFNLEVBQ0osK0JBQStCLEVBQy9CLGNBQWMsRUFDZCxpQkFBaUIsR0FDbEIsR0FBRyxNQUFNLENBQUM7UUFFWCxPQUFPLElBQUksQ0FBQyxZQUFZO2FBQ3JCLHVCQUF1QixDQUFDLFVBQVUsRUFBRSxNQUFNLEVBQUUsVUFBVSxDQUFDO2FBQ3ZELElBQUksQ0FDSCxHQUFHLENBQUMsQ0FBQyxlQUFlLEVBQUUsRUFBRTtZQUN0QixJQUFJLENBQUMsZ0JBQWdCLENBQUMsdUJBQXVCLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDdEQsSUFDRSxDQUFDLCtCQUErQjtnQkFDaEMsQ0FBQyxlQUFlLENBQUMsY0FBYyxFQUMvQjtnQkFDQSxJQUFJLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxjQUFjLENBQUMsQ0FBQzthQUMzQztRQUNILENBQUMsQ0FBQyxFQUNGLFVBQVUsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFO1lBQ25CLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyx1QkFBdUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUN0RCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsdUJBQXVCLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDdEQsSUFBSSxDQUFDLGVBQWUsQ0FBQyxzQkFBc0IsRUFBRSxDQUFDO1lBQzlDLElBQUksQ0FBQywrQkFBK0IsSUFBSSxDQUFDLGNBQWMsRUFBRTtnQkFDdkQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsaUJBQWlCLENBQUMsQ0FBQzthQUM5QztZQUVELE9BQU8sVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDNUMsQ0FBQyxDQUFDLENBQ0gsQ0FBQztJQUNOLENBQUM7OEdBM0NVLHVCQUF1QjtrSEFBdkIsdUJBQXVCLGNBRFYsTUFBTTs7U0FDbkIsdUJBQXVCOzJGQUF2Qix1QkFBdUI7a0JBRG5DLFVBQVU7bUJBQUMsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUm91dGVyIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7IE9ic2VydmFibGUsIHRocm93RXJyb3IgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGNhdGNoRXJyb3IsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IE9wZW5JZENvbmZpZ3VyYXRpb24gfSBmcm9tICcuLi9jb25maWcvb3BlbmlkLWNvbmZpZ3VyYXRpb24nO1xuaW1wb3J0IHsgQ2FsbGJhY2tDb250ZXh0IH0gZnJvbSAnLi4vZmxvd3MvY2FsbGJhY2stY29udGV4dCc7XG5pbXBvcnQgeyBGbG93c0RhdGFTZXJ2aWNlIH0gZnJvbSAnLi4vZmxvd3MvZmxvd3MtZGF0YS5zZXJ2aWNlJztcbmltcG9ydCB7IEZsb3dzU2VydmljZSB9IGZyb20gJy4uL2Zsb3dzL2Zsb3dzLnNlcnZpY2UnO1xuaW1wb3J0IHsgSW50ZXJ2YWxTZXJ2aWNlIH0gZnJvbSAnLi9pbnRlcnZhbC5zZXJ2aWNlJztcblxuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBDb2RlRmxvd0NhbGxiYWNrU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZmxvd3NTZXJ2aWNlOiBGbG93c1NlcnZpY2UsXG4gICAgcHJpdmF0ZSByZWFkb25seSBmbG93c0RhdGFTZXJ2aWNlOiBGbG93c0RhdGFTZXJ2aWNlLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgaW50ZXJ2YWxTZXJ2aWNlOiBJbnRlcnZhbFNlcnZpY2UsXG4gICAgcHJpdmF0ZSByZWFkb25seSByb3V0ZXI6IFJvdXRlclxuICApIHt9XG5cbiAgYXV0aGVudGljYXRlZENhbGxiYWNrV2l0aENvZGUoXG4gICAgdXJsVG9DaGVjazogc3RyaW5nLFxuICAgIGNvbmZpZzogT3BlbklkQ29uZmlndXJhdGlvbixcbiAgICBhbGxDb25maWdzOiBPcGVuSWRDb25maWd1cmF0aW9uW11cbiAgKTogT2JzZXJ2YWJsZTxDYWxsYmFja0NvbnRleHQ+IHtcbiAgICBjb25zdCBpc1JlbmV3UHJvY2VzcyA9IHRoaXMuZmxvd3NEYXRhU2VydmljZS5pc1NpbGVudFJlbmV3UnVubmluZyhjb25maWcpO1xuICAgIGNvbnN0IHtcbiAgICAgIHRyaWdnZXJBdXRob3JpemF0aW9uUmVzdWx0RXZlbnQsXG4gICAgICBwb3N0TG9naW5Sb3V0ZSxcbiAgICAgIHVuYXV0aG9yaXplZFJvdXRlLFxuICAgIH0gPSBjb25maWc7XG5cbiAgICByZXR1cm4gdGhpcy5mbG93c1NlcnZpY2VcbiAgICAgIC5wcm9jZXNzQ29kZUZsb3dDYWxsYmFjayh1cmxUb0NoZWNrLCBjb25maWcsIGFsbENvbmZpZ3MpXG4gICAgICAucGlwZShcbiAgICAgICAgdGFwKChjYWxsYmFja0NvbnRleHQpID0+IHtcbiAgICAgICAgICB0aGlzLmZsb3dzRGF0YVNlcnZpY2UucmVzZXRDb2RlRmxvd0luUHJvZ3Jlc3MoY29uZmlnKTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhdHJpZ2dlckF1dGhvcml6YXRpb25SZXN1bHRFdmVudCAmJlxuICAgICAgICAgICAgIWNhbGxiYWNrQ29udGV4dC5pc1JlbmV3UHJvY2Vzc1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5yb3V0ZXIubmF2aWdhdGVCeVVybChwb3N0TG9naW5Sb3V0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgY2F0Y2hFcnJvcigoZXJyb3IpID0+IHtcbiAgICAgICAgICB0aGlzLmZsb3dzRGF0YVNlcnZpY2UucmVzZXRTaWxlbnRSZW5ld1J1bm5pbmcoY29uZmlnKTtcbiAgICAgICAgICB0aGlzLmZsb3dzRGF0YVNlcnZpY2UucmVzZXRDb2RlRmxvd0luUHJvZ3Jlc3MoY29uZmlnKTtcbiAgICAgICAgICB0aGlzLmludGVydmFsU2VydmljZS5zdG9wUGVyaW9kaWNUb2tlbkNoZWNrKCk7XG4gICAgICAgICAgaWYgKCF0cmlnZ2VyQXV0aG9yaXphdGlvblJlc3VsdEV2ZW50ICYmICFpc1JlbmV3UHJvY2Vzcykge1xuICAgICAgICAgICAgdGhpcy5yb3V0ZXIubmF2aWdhdGVCeVVybCh1bmF1dGhvcml6ZWRSb3V0ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoKCkgPT4gbmV3IEVycm9yKGVycm9yKSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICB9XG59XG4iXX0=