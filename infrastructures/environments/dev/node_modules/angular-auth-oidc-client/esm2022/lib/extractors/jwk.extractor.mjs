import { Injectable } from '@angular/core';
import * as i0 from "@angular/core";
class JwkExtractor {
    extractJwk(keys, spec, throwOnEmpty = true) {
        if (0 === keys.length) {
            throw JwkExtractorInvalidArgumentError;
        }
        const foundKeys = keys
            .filter((k) => (spec?.kid ? k['kid'] === spec.kid : true))
            .filter((k) => (spec?.use ? k['use'] === spec.use : true))
            .filter((k) => (spec?.kty ? k['kty'] === spec.kty : true));
        if (foundKeys.length === 0 && throwOnEmpty) {
            throw JwkExtractorNoMatchingKeysError;
        }
        if (foundKeys.length > 1 && (null === spec || undefined === spec)) {
            throw JwkExtractorSeveralMatchingKeysError;
        }
        return foundKeys;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.2", ngImport: i0, type: JwkExtractor, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.0.2", ngImport: i0, type: JwkExtractor, providedIn: 'root' }); }
}
export { JwkExtractor };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.2", ngImport: i0, type: JwkExtractor, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });
function buildErrorName(name) {
    return JwkExtractor.name + ': ' + name;
}
export const JwkExtractorInvalidArgumentError = {
    name: buildErrorName('InvalidArgumentError'),
    message: 'Array of keys was empty. Unable to extract',
};
export const JwkExtractorNoMatchingKeysError = {
    name: buildErrorName('NoMatchingKeysError'),
    message: 'No key found matching the spec',
};
export const JwkExtractorSeveralMatchingKeysError = {
    name: buildErrorName('SeveralMatchingKeysError'),
    message: 'More than one key found. Please use spec to filter',
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiandrLmV4dHJhY3Rvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXItYXV0aC1vaWRjLWNsaWVudC9zcmMvbGliL2V4dHJhY3RvcnMvandrLmV4dHJhY3Rvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDOztBQUUzQyxNQUNhLFlBQVk7SUFDdkIsVUFBVSxDQUNSLElBQWtCLEVBQ2xCLElBQW1ELEVBQ25ELFlBQVksR0FBRyxJQUFJO1FBRW5CLElBQUksQ0FBQyxLQUFLLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDckIsTUFBTSxnQ0FBZ0MsQ0FBQztTQUN4QztRQUVELE1BQU0sU0FBUyxHQUFHLElBQUk7YUFDbkIsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUN6RCxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ3pELE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUU3RCxJQUFJLFNBQVMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxJQUFJLFlBQVksRUFBRTtZQUMxQyxNQUFNLCtCQUErQixDQUFDO1NBQ3ZDO1FBRUQsSUFBSSxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksS0FBSyxJQUFJLElBQUksU0FBUyxLQUFLLElBQUksQ0FBQyxFQUFFO1lBQ2pFLE1BQU0sb0NBQW9DLENBQUM7U0FDNUM7UUFFRCxPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDOzhHQXhCVSxZQUFZO2tIQUFaLFlBQVksY0FEQyxNQUFNOztTQUNuQixZQUFZOzJGQUFaLFlBQVk7a0JBRHhCLFVBQVU7bUJBQUMsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFOztBQTRCbEMsU0FBUyxjQUFjLENBQUMsSUFBWTtJQUNsQyxPQUFPLFlBQVksQ0FBQyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksQ0FBQztBQUN6QyxDQUFDO0FBRUQsTUFBTSxDQUFDLE1BQU0sZ0NBQWdDLEdBQUc7SUFDOUMsSUFBSSxFQUFFLGNBQWMsQ0FBQyxzQkFBc0IsQ0FBQztJQUM1QyxPQUFPLEVBQUUsNENBQTRDO0NBQ3RELENBQUM7QUFFRixNQUFNLENBQUMsTUFBTSwrQkFBK0IsR0FBRztJQUM3QyxJQUFJLEVBQUUsY0FBYyxDQUFDLHFCQUFxQixDQUFDO0lBQzNDLE9BQU8sRUFBRSxnQ0FBZ0M7Q0FDMUMsQ0FBQztBQUVGLE1BQU0sQ0FBQyxNQUFNLG9DQUFvQyxHQUFHO0lBQ2xELElBQUksRUFBRSxjQUFjLENBQUMsMEJBQTBCLENBQUM7SUFDaEQsT0FBTyxFQUFFLG9EQUFvRDtDQUM5RCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ASW5qZWN0YWJsZSh7IHByb3ZpZGVkSW46ICdyb290JyB9KVxuZXhwb3J0IGNsYXNzIEp3a0V4dHJhY3RvciB7XG4gIGV4dHJhY3RKd2soXG4gICAga2V5czogSnNvbldlYktleVtdLFxuICAgIHNwZWM/OiB7IGtpZD86IHN0cmluZzsgdXNlPzogc3RyaW5nOyBrdHk/OiBzdHJpbmcgfSxcbiAgICB0aHJvd09uRW1wdHkgPSB0cnVlXG4gICk6IEpzb25XZWJLZXlbXSB7XG4gICAgaWYgKDAgPT09IGtleXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBKd2tFeHRyYWN0b3JJbnZhbGlkQXJndW1lbnRFcnJvcjtcbiAgICB9XG5cbiAgICBjb25zdCBmb3VuZEtleXMgPSBrZXlzXG4gICAgICAuZmlsdGVyKChrKSA9PiAoc3BlYz8ua2lkID8ga1sna2lkJ10gPT09IHNwZWMua2lkIDogdHJ1ZSkpXG4gICAgICAuZmlsdGVyKChrKSA9PiAoc3BlYz8udXNlID8ga1sndXNlJ10gPT09IHNwZWMudXNlIDogdHJ1ZSkpXG4gICAgICAuZmlsdGVyKChrKSA9PiAoc3BlYz8ua3R5ID8ga1sna3R5J10gPT09IHNwZWMua3R5IDogdHJ1ZSkpO1xuXG4gICAgaWYgKGZvdW5kS2V5cy5sZW5ndGggPT09IDAgJiYgdGhyb3dPbkVtcHR5KSB7XG4gICAgICB0aHJvdyBKd2tFeHRyYWN0b3JOb01hdGNoaW5nS2V5c0Vycm9yO1xuICAgIH1cblxuICAgIGlmIChmb3VuZEtleXMubGVuZ3RoID4gMSAmJiAobnVsbCA9PT0gc3BlYyB8fCB1bmRlZmluZWQgPT09IHNwZWMpKSB7XG4gICAgICB0aHJvdyBKd2tFeHRyYWN0b3JTZXZlcmFsTWF0Y2hpbmdLZXlzRXJyb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvdW5kS2V5cztcbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZEVycm9yTmFtZShuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gSndrRXh0cmFjdG9yLm5hbWUgKyAnOiAnICsgbmFtZTtcbn1cblxuZXhwb3J0IGNvbnN0IEp3a0V4dHJhY3RvckludmFsaWRBcmd1bWVudEVycm9yID0ge1xuICBuYW1lOiBidWlsZEVycm9yTmFtZSgnSW52YWxpZEFyZ3VtZW50RXJyb3InKSxcbiAgbWVzc2FnZTogJ0FycmF5IG9mIGtleXMgd2FzIGVtcHR5LiBVbmFibGUgdG8gZXh0cmFjdCcsXG59O1xuXG5leHBvcnQgY29uc3QgSndrRXh0cmFjdG9yTm9NYXRjaGluZ0tleXNFcnJvciA9IHtcbiAgbmFtZTogYnVpbGRFcnJvck5hbWUoJ05vTWF0Y2hpbmdLZXlzRXJyb3InKSxcbiAgbWVzc2FnZTogJ05vIGtleSBmb3VuZCBtYXRjaGluZyB0aGUgc3BlYycsXG59O1xuXG5leHBvcnQgY29uc3QgSndrRXh0cmFjdG9yU2V2ZXJhbE1hdGNoaW5nS2V5c0Vycm9yID0ge1xuICBuYW1lOiBidWlsZEVycm9yTmFtZSgnU2V2ZXJhbE1hdGNoaW5nS2V5c0Vycm9yJyksXG4gIG1lc3NhZ2U6ICdNb3JlIHRoYW4gb25lIGtleSBmb3VuZC4gUGxlYXNlIHVzZSBzcGVjIHRvIGZpbHRlcicsXG59O1xuIl19