import { Injectable } from '@angular/core';
import * as i0 from "@angular/core";
import * as i1 from "../utils/crypto/crypto.service";
class JwkWindowCryptoService {
    constructor(cryptoService) {
        this.cryptoService = cryptoService;
    }
    importVerificationKey(key, algorithm) {
        return this.cryptoService
            .getCrypto()
            .subtle.importKey('jwk', key, algorithm, false, ['verify']);
    }
    verifyKey(verifyAlgorithm, cryptoKey, signature, signingInput) {
        return this.cryptoService
            .getCrypto()
            .subtle.verify(verifyAlgorithm, cryptoKey, signature, new TextEncoder().encode(signingInput));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.2", ngImport: i0, type: JwkWindowCryptoService, deps: [{ token: i1.CryptoService }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.0.2", ngImport: i0, type: JwkWindowCryptoService, providedIn: 'root' }); }
}
export { JwkWindowCryptoService };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.2", ngImport: i0, type: JwkWindowCryptoService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i1.CryptoService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiandrLXdpbmRvdy1jcnlwdG8uc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXItYXV0aC1vaWRjLWNsaWVudC9zcmMvbGliL3ZhbGlkYXRpb24vandrLXdpbmRvdy1jcnlwdG8uc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDOzs7QUFHM0MsTUFDYSxzQkFBc0I7SUFDakMsWUFBNkIsYUFBNEI7UUFBNUIsa0JBQWEsR0FBYixhQUFhLENBQWU7SUFBRyxDQUFDO0lBRTdELHFCQUFxQixDQUNuQixHQUFlLEVBQ2YsU0FLbUI7UUFFbkIsT0FBTyxJQUFJLENBQUMsYUFBYTthQUN0QixTQUFTLEVBQUU7YUFDWCxNQUFNLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7SUFDaEUsQ0FBQztJQUVELFNBQVMsQ0FDUCxlQUFpRSxFQUNqRSxTQUFvQixFQUNwQixTQUF1QixFQUN2QixZQUFvQjtRQUVwQixPQUFPLElBQUksQ0FBQyxhQUFhO2FBQ3RCLFNBQVMsRUFBRTthQUNYLE1BQU0sQ0FBQyxNQUFNLENBQ1osZUFBZSxFQUNmLFNBQVMsRUFDVCxTQUFTLEVBQ1QsSUFBSSxXQUFXLEVBQUUsQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQ3ZDLENBQUM7SUFDTixDQUFDOzhHQS9CVSxzQkFBc0I7a0hBQXRCLHNCQUFzQixjQURULE1BQU07O1NBQ25CLHNCQUFzQjsyRkFBdEIsc0JBQXNCO2tCQURsQyxVQUFVO21CQUFDLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENyeXB0b1NlcnZpY2UgfSBmcm9tICcuLi91dGlscy9jcnlwdG8vY3J5cHRvLnNlcnZpY2UnO1xuXG5ASW5qZWN0YWJsZSh7IHByb3ZpZGVkSW46ICdyb290JyB9KVxuZXhwb3J0IGNsYXNzIEp3a1dpbmRvd0NyeXB0b1NlcnZpY2Uge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGNyeXB0b1NlcnZpY2U6IENyeXB0b1NlcnZpY2UpIHt9XG5cbiAgaW1wb3J0VmVyaWZpY2F0aW9uS2V5KFxuICAgIGtleTogSnNvbldlYktleSxcbiAgICBhbGdvcml0aG06XG4gICAgICB8IEFsZ29yaXRobUlkZW50aWZpZXJcbiAgICAgIHwgUnNhSGFzaGVkSW1wb3J0UGFyYW1zXG4gICAgICB8IEVjS2V5SW1wb3J0UGFyYW1zXG4gICAgICB8IEhtYWNJbXBvcnRQYXJhbXNcbiAgICAgIHwgQWVzS2V5QWxnb3JpdGhtXG4gICk6IFByb21pc2U8Q3J5cHRvS2V5PiB7XG4gICAgcmV0dXJuIHRoaXMuY3J5cHRvU2VydmljZVxuICAgICAgLmdldENyeXB0bygpXG4gICAgICAuc3VidGxlLmltcG9ydEtleSgnandrJywga2V5LCBhbGdvcml0aG0sIGZhbHNlLCBbJ3ZlcmlmeSddKTtcbiAgfVxuXG4gIHZlcmlmeUtleShcbiAgICB2ZXJpZnlBbGdvcml0aG06IEFsZ29yaXRobUlkZW50aWZpZXIgfCBSc2FQc3NQYXJhbXMgfCBFY2RzYVBhcmFtcyxcbiAgICBjcnlwdG9LZXk6IENyeXB0b0tleSxcbiAgICBzaWduYXR1cmU6IEJ1ZmZlclNvdXJjZSxcbiAgICBzaWduaW5nSW5wdXQ6IHN0cmluZ1xuICApOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5jcnlwdG9TZXJ2aWNlXG4gICAgICAuZ2V0Q3J5cHRvKClcbiAgICAgIC5zdWJ0bGUudmVyaWZ5KFxuICAgICAgICB2ZXJpZnlBbGdvcml0aG0sXG4gICAgICAgIGNyeXB0b0tleSxcbiAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc2lnbmluZ0lucHV0KVxuICAgICAgKTtcbiAgfVxufVxuIl19