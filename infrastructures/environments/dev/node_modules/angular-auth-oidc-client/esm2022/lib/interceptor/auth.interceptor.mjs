import { Injectable, inject } from '@angular/core';
import { AuthStateService } from '../auth-state/auth-state.service';
import { ConfigurationService } from '../config/config.service';
import { LoggerService } from '../logging/logger.service';
import { ClosestMatchingRouteService } from './closest-matching-route.service';
import * as i0 from "@angular/core";
import * as i1 from "../auth-state/auth-state.service";
import * as i2 from "../config/config.service";
import * as i3 from "../logging/logger.service";
import * as i4 from "./closest-matching-route.service";
class AuthInterceptor {
    constructor(authStateService, configurationService, loggerService, closestMatchingRouteService) {
        this.authStateService = authStateService;
        this.configurationService = configurationService;
        this.loggerService = loggerService;
        this.closestMatchingRouteService = closestMatchingRouteService;
    }
    intercept(req, next) {
        return interceptRequest(req, next.handle, {
            configurationService: this.configurationService,
            authStateService: this.authStateService,
            closestMatchingRouteService: this.closestMatchingRouteService,
            loggerService: this.loggerService,
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.2", ngImport: i0, type: AuthInterceptor, deps: [{ token: i1.AuthStateService }, { token: i2.ConfigurationService }, { token: i3.LoggerService }, { token: i4.ClosestMatchingRouteService }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.0.2", ngImport: i0, type: AuthInterceptor }); }
}
export { AuthInterceptor };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.2", ngImport: i0, type: AuthInterceptor, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.AuthStateService }, { type: i2.ConfigurationService }, { type: i3.LoggerService }, { type: i4.ClosestMatchingRouteService }]; } });
export function authInterceptor() {
    return (req, next) => {
        return interceptRequest(req, next, {
            configurationService: inject(ConfigurationService),
            authStateService: inject(AuthStateService),
            closestMatchingRouteService: inject(ClosestMatchingRouteService),
            loggerService: inject(LoggerService),
        });
    };
}
function interceptRequest(req, next, deps) {
    if (!deps.configurationService.hasAtLeastOneConfig()) {
        return next(req);
    }
    const allConfigurations = deps.configurationService.getAllConfigurations();
    const allRoutesConfigured = allConfigurations.map((x) => x.secureRoutes || []);
    const allRoutesConfiguredFlat = [].concat(...allRoutesConfigured);
    if (allRoutesConfiguredFlat.length === 0) {
        deps.loggerService.logDebug(allConfigurations[0], `No routes to check configured`);
        return next(req);
    }
    const { matchingConfig, matchingRoute } = deps.closestMatchingRouteService.getConfigIdForClosestMatchingRoute(req.url, allConfigurations);
    if (!matchingConfig) {
        deps.loggerService.logDebug(allConfigurations[0], `Did not find any configured route for route ${req.url}`);
        return next(req);
    }
    deps.loggerService.logDebug(matchingConfig, `'${req.url}' matches configured route '${matchingRoute}'`);
    const token = deps.authStateService.getAccessToken(matchingConfig);
    if (!token) {
        deps.loggerService.logDebug(matchingConfig, `Wanted to add token to ${req.url} but found no token: '${token}'`);
        return next(req);
    }
    deps.loggerService.logDebug(matchingConfig, `'${req.url}' matches configured route '${matchingRoute}', adding token`);
    req = req.clone({
        headers: req.headers.set('Authorization', 'Bearer ' + token),
    });
    return next(req);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0aC5pbnRlcmNlcHRvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXItYXV0aC1vaWRjLWNsaWVudC9zcmMvbGliL2ludGVyY2VwdG9yL2F1dGguaW50ZXJjZXB0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBUUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFbkQsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sa0NBQWtDLENBQUM7QUFDcEUsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDaEUsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQzFELE9BQU8sRUFBRSwyQkFBMkIsRUFBRSxNQUFNLGtDQUFrQyxDQUFDOzs7Ozs7QUFFL0UsTUFDYSxlQUFlO0lBQzFCLFlBQ21CLGdCQUFrQyxFQUNsQyxvQkFBMEMsRUFDMUMsYUFBNEIsRUFDNUIsMkJBQXdEO1FBSHhELHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBa0I7UUFDbEMseUJBQW9CLEdBQXBCLG9CQUFvQixDQUFzQjtRQUMxQyxrQkFBYSxHQUFiLGFBQWEsQ0FBZTtRQUM1QixnQ0FBMkIsR0FBM0IsMkJBQTJCLENBQTZCO0lBQ3hFLENBQUM7SUFFSixTQUFTLENBQ1AsR0FBcUIsRUFDckIsSUFBaUI7UUFFakIsT0FBTyxnQkFBZ0IsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUN4QyxvQkFBb0IsRUFBRSxJQUFJLENBQUMsb0JBQW9CO1lBQy9DLGdCQUFnQixFQUFFLElBQUksQ0FBQyxnQkFBZ0I7WUFDdkMsMkJBQTJCLEVBQUUsSUFBSSxDQUFDLDJCQUEyQjtZQUM3RCxhQUFhLEVBQUUsSUFBSSxDQUFDLGFBQWE7U0FDbEMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQzs4R0FsQlUsZUFBZTtrSEFBZixlQUFlOztTQUFm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SHR0cEhhbmRsZXIsXG4gIEh0dHBIYW5kbGVyRm4sXG4gIEh0dHBJbnRlcmNlcHRvcixcbiAgSHR0cEludGVyY2VwdG9yRm4sXG4gIEh0dHBSZXF1ZXN0LFxufSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQgeyBJbmplY3RhYmxlLCBpbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IEF1dGhTdGF0ZVNlcnZpY2UgfSBmcm9tICcuLi9hdXRoLXN0YXRlL2F1dGgtc3RhdGUuc2VydmljZSc7XG5pbXBvcnQgeyBDb25maWd1cmF0aW9uU2VydmljZSB9IGZyb20gJy4uL2NvbmZpZy9jb25maWcuc2VydmljZSc7XG5pbXBvcnQgeyBMb2dnZXJTZXJ2aWNlIH0gZnJvbSAnLi4vbG9nZ2luZy9sb2dnZXIuc2VydmljZSc7XG5pbXBvcnQgeyBDbG9zZXN0TWF0Y2hpbmdSb3V0ZVNlcnZpY2UgfSBmcm9tICcuL2Nsb3Nlc3QtbWF0Y2hpbmctcm91dGUuc2VydmljZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBBdXRoSW50ZXJjZXB0b3IgaW1wbGVtZW50cyBIdHRwSW50ZXJjZXB0b3Ige1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGF1dGhTdGF0ZVNlcnZpY2U6IEF1dGhTdGF0ZVNlcnZpY2UsXG4gICAgcHJpdmF0ZSByZWFkb25seSBjb25maWd1cmF0aW9uU2VydmljZTogQ29uZmlndXJhdGlvblNlcnZpY2UsXG4gICAgcHJpdmF0ZSByZWFkb25seSBsb2dnZXJTZXJ2aWNlOiBMb2dnZXJTZXJ2aWNlLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY2xvc2VzdE1hdGNoaW5nUm91dGVTZXJ2aWNlOiBDbG9zZXN0TWF0Y2hpbmdSb3V0ZVNlcnZpY2VcbiAgKSB7fVxuXG4gIGludGVyY2VwdChcbiAgICByZXE6IEh0dHBSZXF1ZXN0PGFueT4sXG4gICAgbmV4dDogSHR0cEhhbmRsZXJcbiAgKTogT2JzZXJ2YWJsZTxIdHRwRXZlbnQ8YW55Pj4ge1xuICAgIHJldHVybiBpbnRlcmNlcHRSZXF1ZXN0KHJlcSwgbmV4dC5oYW5kbGUsIHtcbiAgICAgIGNvbmZpZ3VyYXRpb25TZXJ2aWNlOiB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlLFxuICAgICAgYXV0aFN0YXRlU2VydmljZTogdGhpcy5hdXRoU3RhdGVTZXJ2aWNlLFxuICAgICAgY2xvc2VzdE1hdGNoaW5nUm91dGVTZXJ2aWNlOiB0aGlzLmNsb3Nlc3RNYXRjaGluZ1JvdXRlU2VydmljZSxcbiAgICAgIGxvZ2dlclNlcnZpY2U6IHRoaXMubG9nZ2VyU2VydmljZSxcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXV0aEludGVyY2VwdG9yKCk6IEh0dHBJbnRlcmNlcHRvckZuIHtcbiAgcmV0dXJuIChyZXEsIG5leHQpID0+IHtcbiAgICByZXR1cm4gaW50ZXJjZXB0UmVxdWVzdChyZXEsIG5leHQsIHtcbiAgICAgIGNvbmZpZ3VyYXRpb25TZXJ2aWNlOiBpbmplY3QoQ29uZmlndXJhdGlvblNlcnZpY2UpLFxuICAgICAgYXV0aFN0YXRlU2VydmljZTogaW5qZWN0KEF1dGhTdGF0ZVNlcnZpY2UpLFxuICAgICAgY2xvc2VzdE1hdGNoaW5nUm91dGVTZXJ2aWNlOiBpbmplY3QoQ2xvc2VzdE1hdGNoaW5nUm91dGVTZXJ2aWNlKSxcbiAgICAgIGxvZ2dlclNlcnZpY2U6IGluamVjdChMb2dnZXJTZXJ2aWNlKSxcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW50ZXJjZXB0UmVxdWVzdChcbiAgcmVxOiBIdHRwUmVxdWVzdDxhbnk+LFxuICBuZXh0OiBIdHRwSGFuZGxlckZuLFxuICBkZXBzOiB7XG4gICAgYXV0aFN0YXRlU2VydmljZTogQXV0aFN0YXRlU2VydmljZTtcbiAgICBjb25maWd1cmF0aW9uU2VydmljZTogQ29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgbG9nZ2VyU2VydmljZTogTG9nZ2VyU2VydmljZTtcbiAgICBjbG9zZXN0TWF0Y2hpbmdSb3V0ZVNlcnZpY2U6IENsb3Nlc3RNYXRjaGluZ1JvdXRlU2VydmljZTtcbiAgfVxuKTogT2JzZXJ2YWJsZTxIdHRwRXZlbnQ8dW5rbm93bj4+IHtcbiAgaWYgKCFkZXBzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlLmhhc0F0TGVhc3RPbmVDb25maWcoKSkge1xuICAgIHJldHVybiBuZXh0KHJlcSk7XG4gIH1cblxuICBjb25zdCBhbGxDb25maWd1cmF0aW9ucyA9IGRlcHMuY29uZmlndXJhdGlvblNlcnZpY2UuZ2V0QWxsQ29uZmlndXJhdGlvbnMoKTtcbiAgY29uc3QgYWxsUm91dGVzQ29uZmlndXJlZCA9IGFsbENvbmZpZ3VyYXRpb25zLm1hcChcbiAgICAoeCkgPT4geC5zZWN1cmVSb3V0ZXMgfHwgW11cbiAgKTtcbiAgY29uc3QgYWxsUm91dGVzQ29uZmlndXJlZEZsYXQgPSBbXS5jb25jYXQoLi4uYWxsUm91dGVzQ29uZmlndXJlZCkgYXMgc3RyaW5nW107XG5cbiAgaWYgKGFsbFJvdXRlc0NvbmZpZ3VyZWRGbGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgIGRlcHMubG9nZ2VyU2VydmljZS5sb2dEZWJ1ZyhcbiAgICAgIGFsbENvbmZpZ3VyYXRpb25zWzBdLFxuICAgICAgYE5vIHJvdXRlcyB0byBjaGVjayBjb25maWd1cmVkYFxuICAgICk7XG5cbiAgICByZXR1cm4gbmV4dChyZXEpO1xuICB9XG5cbiAgY29uc3QgeyBtYXRjaGluZ0NvbmZpZywgbWF0Y2hpbmdSb3V0ZSB9ID1cbiAgICBkZXBzLmNsb3Nlc3RNYXRjaGluZ1JvdXRlU2VydmljZS5nZXRDb25maWdJZEZvckNsb3Nlc3RNYXRjaGluZ1JvdXRlKFxuICAgICAgcmVxLnVybCxcbiAgICAgIGFsbENvbmZpZ3VyYXRpb25zXG4gICAgKTtcblxuICBpZiAoIW1hdGNoaW5nQ29uZmlnKSB7XG4gICAgZGVwcy5sb2dnZXJTZXJ2aWNlLmxvZ0RlYnVnKFxuICAgICAgYWxsQ29uZmlndXJhdGlvbnNbMF0sXG4gICAgICBgRGlkIG5vdCBmaW5kIGFueSBjb25maWd1cmVkIHJvdXRlIGZvciByb3V0ZSAke3JlcS51cmx9YFxuICAgICk7XG5cbiAgICByZXR1cm4gbmV4dChyZXEpO1xuICB9XG5cbiAgZGVwcy5sb2dnZXJTZXJ2aWNlLmxvZ0RlYnVnKFxuICAgIG1hdGNoaW5nQ29uZmlnLFxuICAgIGAnJHtyZXEudXJsfScgbWF0Y2hlcyBjb25maWd1cmVkIHJvdXRlICcke21hdGNoaW5nUm91dGV9J2BcbiAgKTtcbiAgY29uc3QgdG9rZW4gPSBkZXBzLmF1dGhTdGF0ZVNlcnZpY2UuZ2V0QWNjZXNzVG9rZW4obWF0Y2hpbmdDb25maWcpO1xuXG4gIGlmICghdG9rZW4pIHtcbiAgICBkZXBzLmxvZ2dlclNlcnZpY2UubG9nRGVidWcoXG4gICAgICBtYXRjaGluZ0NvbmZpZyxcbiAgICAgIGBXYW50ZWQgdG8gYWRkIHRva2VuIHRvICR7cmVxLnVybH0gYnV0IGZvdW5kIG5vIHRva2VuOiAnJHt0b2tlbn0nYFxuICAgICk7XG5cbiAgICByZXR1cm4gbmV4dChyZXEpO1xuICB9XG5cbiAgZGVwcy5sb2dnZXJTZXJ2aWNlLmxvZ0RlYnVnKFxuICAgIG1hdGNoaW5nQ29uZmlnLFxuICAgIGAnJHtyZXEudXJsfScgbWF0Y2hlcyBjb25maWd1cmVkIHJvdXRlICcke21hdGNoaW5nUm91dGV9JywgYWRkaW5nIHRva2VuYFxuICApO1xuICByZXEgPSByZXEuY2xvbmUoe1xuICAgIGhlYWRlcnM6IHJlcS5oZWFkZXJzLnNldCgnQXV0aG9yaXphdGlvbicsICdCZWFyZXIgJyArIHRva2VuKSxcbiAgfSk7XG5cbiAgcmV0dXJuIG5leHQocmVxKTtcbn1cbiJdfQ==